# 섹션 02 연습 문제: useRef와 기타 Hooks

> **관련 개념**: `concept.md` 참조
> **코드 템플릿**: `exercise.jsx`
> **모범 답안**: `solution.jsx` 참조

---

## 문제 1: useRef 시뮬레이션 (⭐)

### 설명
React의 useRef 동작을 시뮬레이션하는 함수를 작성하세요. `{ current: initialValue }` 형태의 ref 객체를 생성합니다.

### 요구 사항
- 초기값을 받아 `{ current: initialValue }` 객체를 반환합니다
- `current` 속성을 자유롭게 읽고 쓸 수 있습니다
- 값을 변경해도 별도의 부수 효과(콜백 호출 등)가 없습니다

---

## 문제 2: useMemo 시뮬레이션 (⭐⭐)

### 설명
React의 useMemo 동작을 시뮬레이션하는 함수를 작성하세요. 의존성이 변경되었을 때만 계산 함수를 실행하고, 그렇지 않으면 캐싱된 값을 반환합니다.

### 요구 사항
- 계산 함수(computeFn)를 받아 메모이제이션 객체를 생성합니다
- `get(deps)` 메서드로 의존성 배열을 전달하면 값을 반환합니다
- 의존성이 같으면 캐싱된 값을 반환합니다 (computeFn 호출 안 함)
- 의존성이 변경되면 computeFn을 다시 실행합니다

---

## 문제 3: 이전 값 추적 (⭐⭐)

### 설명
useRef를 사용한 "이전 값 추적" 패턴을 시뮬레이션하세요. 값을 업데이트할 때마다 이전 값을 기억하는 함수입니다.

### 요구 사항
- `update(newValue)`로 새 값을 설정합니다
- `getCurrent()`로 현재 값을 반환합니다
- `getPrevious()`로 이전 값을 반환합니다
- `getHistory()`로 모든 값의 이력을 배열로 반환합니다

---

## 채점 기준

| 항목 | 배점 |
|------|------|
| 정확한 동작 | 40% |
| 코드 가독성 | 20% |
| 엣지 케이스 처리 | 20% |
| 효율성 | 20% |

---

> **팁**: useRef의 핵심은 "변경해도 리렌더링이 없다"는 것이고, useMemo의 핵심은 "의존성이 같으면 재계산하지 않는다"는 것입니다.
