# 섹션 01 연습 문제: useEffect

> **관련 개념**: `concept.md` 참조
> **코드 템플릿**: `exercise.jsx`
> **모범 답안**: `solution.jsx` 참조

---

## 문제 1: 이펙트 시뮬레이션 (⭐⭐)

### 설명
React의 useEffect 동작을 시뮬레이션하는 `createEffect` 함수를 작성하세요. 의존성 배열의 값이 변경되었을 때만 콜백을 실행하는 핵심 로직을 구현합니다.

### 요구 사항
- `run(callback, deps)` 메서드로 이펙트를 실행합니다
- 첫 번째 호출 시 항상 콜백을 실행합니다
- 이후 호출 시 의존성이 변경된 경우에만 콜백을 실행합니다
- 콜백이 함수를 반환하면 클린업 함수로 저장하고, 다음 실행 전에 호출합니다
- `cleanup()` 메서드로 현재 클린업 함수를 수동으로 실행할 수 있습니다

---

## 문제 2: 타이머 시뮬레이션 (⭐⭐)

### 설명
`setInterval`을 사용하는 타이머를 시뮬레이션하세요. useEffect + setInterval 패턴에서 클린업 함수로 타이머를 해제하는 것이 핵심입니다.

### 요구 사항
- `start(callback, interval)` 메서드로 타이머를 시작합니다
- `stop()` 메서드로 타이머를 정지합니다
- `isRunning()` 메서드로 타이머 실행 상태를 확인합니다
- `getTickCount()` 메서드로 콜백이 호출된 횟수를 반환합니다
- 이미 실행 중이면 `start()` 호출 시 기존 타이머를 정지하고 새로 시작합니다

---

## 문제 3: 데이터 페처 시뮬레이션 (⭐⭐⭐)

### 설명
비동기 데이터 가져오기를 시뮬레이션하세요. useEffect에서 데이터를 가져올 때의 loading/error/data 상태 관리 패턴을 구현합니다.

### 요구 사항
- 비동기 함수(fetchFn)를 받아 데이터 페처를 생성합니다
- `fetch()` 호출 시 loading/data/error 상태를 관리합니다
- `getState()` 메서드로 현재 상태 `{ loading, data, error }`를 반환합니다
- 이전 요청이 완료되기 전에 새 요청이 시작되면 이전 결과를 무시합니다 (경쟁 조건 방지)

---

## 채점 기준

| 항목 | 배점 |
|------|------|
| 정확한 동작 | 40% |
| 코드 가독성 | 20% |
| 엣지 케이스 처리 | 20% |
| 효율성 | 20% |

---

> **팁**: useEffect의 핵심은 "의존성이 변경되었을 때만 실행"과 "클린업으로 이전 이펙트 정리"입니다. 이 두 가지를 정확히 구현하는 데 집중하세요.
